### 77. Combinations

**Backtracking**    [ğŸ§¡](https://leetcode.com/problems/combinations)    

#### Description

Given two integers _n_ and _k_, return all possible combinations of _k_ numbers out of 1 ... _n_.

**Example:**

```
Input:Â n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

#### Analysis

ç»„åˆé—®é¢˜ã€‚

é€šå¸¸é€’å½’è§£æ³•ã€‚

##### é€’å½’1

$$ C^{k}_{n} = C^{k-1}_{n-1} + C^{k}_{n-1} $$

- $ C^{k-1}_{n-1} $ æ˜¯æŒ‡å›ºå®šå– `[n]`ï¼Œ ä»å‰©ä¸‹çš„ `n-1` ä¸ªæ•°ä¸­å†å– `k-1` ä¸ªã€‚
- å½“ `k == 1` æ—¶ï¼Œ è¿”å› `[[1], [2], [3], ..., [n]]`
- å½“ `k == n` æ—¶ï¼Œ è¿”å› `[[1, 2, 3, ..., n]]`

```python
def combine(self, n, k):
    if k == 1:
        return [[i] for i in range(1, n + 1)]
    elif k == n:
        return [list(range(1, k + 1))]

    sub = self.combine(n - 1, k - 1)
    for c in sub:
        c.append(n)
    return sub + self.combine(n - 1, k)
```

è¾ƒå¿«ï¼ˆ27/27, 135msï¼‰

##### é€’å½’2

è¿˜æœ‰ä¸€ç§æ€è·¯æ˜¯ $$ C^k_n = C^{k-1}_{n-1} + C^{k-1}_{n-2} + \cdots + C^{k-1}_{k-1} $$

- å›ºå®šå– `[n]`ï¼Œ å†ä»å‰©ä¸‹çš„ `n-1` ä¸ªå– `k-1` ä¸ª
- å›ºå®šæœ€å¤§å– `[n-1]`ï¼Œä»å‰©ä¸‹çš„ `n-2` ä¸ªå– `k-1` ä¸ª
- ...
- å›ºå®šæœ€å¤§å– `[k]`ï¼Œ ä»å‰©ä¸‹çš„ `k-1` ä¸ªå– `k-1` ä¸ª

```python
def combine(self, n, k):
    if k == 1:
        return [[i] for i in range(1, n + 1)]
    elif k == n:
        return [list(range(1, k + 1))]
    return [c + [i] for i in range(k, n + 1) for c in self.combine(i - 1, k - 1)]
```

è¾ƒæ…¢

##### éé€’å½’1

ä¸€ç§è‡ªåº•å‘ä¸Šçš„æ–¹æ³•æ˜¯ï¼Œå…ˆæ„é€  $C_n^1$ ï¼Œç„¶ååœ¨æ¯ä¸ªç»„åˆä¸Šé¢æ·»åŠ ä¸€ä¸ª æ„é€  $C_n^2$ï¼Œä¸ºäº†é¿å…é‡å¤ï¼Œé™å®šåªæ·»åŠ å°äºç»„åˆæœ€å°å€¼çš„å€¼ï¼ˆæˆ–è€…å¤§äºç»„åˆæœ€å¤§å€¼çš„å€¼ï¼‰ã€‚

```python
def combine(self, n, k):
    combinations = [[i] for i in range(1, n + 1)]
    for _ in range(k - 1):
        combinations = [c + [i] for c in combinations for i in range(c[-1] + 1, n + 1)]
    return combinations
```

ææ…¢ã€‚ï¼ˆ27/27, 912msï¼‰ã€‚


##### éé€’å½’2

è¿™ä¸ªå‚è€ƒ <https://leetcode.com/problems/combinations/discuss/27029/AC-Python-backtracking-iterative-solution-60-ms>

æ˜¯æœ€å¿«çš„éé€’å½’çš„è§£ï¼Œæ–¹æ³•å¾ˆç²¾å¦™ã€‚ä½†æ˜¯ä¸å¤ªå–œæ¬¢è¿™ç§ä»£ç é£æ ¼ã€‚

è¿™ç§æ–¹æ³•çš„æ€æƒ³æ˜¯ï¼š å…ˆæ„é€ ä¸€ä¸ªç»„åˆ `[1, 2, ..., k]`ï¼Œ ç„¶åä»åå‘å‰æ›¿æ¢ä¸€ä¸ªï¼ˆå¤§1çš„ï¼‰å€¼ï¼Œä»¥æ„é€ æ–°çš„ç»„åˆã€‚ æ˜¯ä¸€ç§éé€’å½’å¼å›æº¯ï¼ˆbacktrackingï¼‰æ–¹æ³•ã€‚

```python
def combine(self, n, k):
    ans = []
    stack = list(range(1, k + 1))
    choice = k + 1
    while True:
        l = len(stack)
        if l == k:
            ans.append(stack[:])       # find a combination
        if l == k or choice > n - k + l + 1:  # go back if choice + k - l - 1 > n;
            if not stack:
                return ans
            choice = stack.pop() + 1
        else:
            stack.append(choice)       # append choice
            choice += 1
```

æ³¨æ„é‡Œé¢ æ¯”è¾ƒéš¾ç†è§£çš„æ˜¯ï¼š`choice > n - k + l + 1`ã€‚ è¿™ä¸ªæ˜¯å‰ªæçš„å…³é”®ï¼Œä¹Ÿæ˜¯è¿™ä¸ªç®—æ³•é€Ÿåº¦å¿«çš„åŸå› ã€‚

æ³¨æ„å¦‚æœè¦ æ·»åŠ ä¸€ä¸ª choiceï¼Œ åˆ™æ·»åŠ ä½ç½®æ˜¯ `l + 1`ï¼› å¦‚æœç»§ç»­æ·»åŠ ï¼Œåˆ™ åˆ° ç¬¬ `k` ä¸ªä½ç½®å°±æ˜¯ `choice + k - l - 1`ã€‚å¦‚æœè¿™ä¸ªæ•°å¤§äº `n`ï¼Œé‚£ä¹ˆè¿™ç§ç»„åˆæ˜¯ä¸å­˜åœ¨çš„ï¼Œæ‰€ä»¥å¯ä»¥æå‰å‰ªæã€‚

##### python got 100, you got 1, for you known the build-in function

```python
def combine(self, n, k):
    return list(combinations(range(1, n + 1), k))
```

#### [Code](../python/77.%20Combinations.py)
