### 78. Subsets

**Bit Manipulation**, **Array**, **Backtracking**    [ğŸ§¡](https://leetcode.com/problems/subsets)    

#### Description

Given a set of **distinct** integers, _nums_, return all possible subsets (the power set).

**Note:** The solution set must not contain duplicate subsets.

**Example:**

```
Input: nums = [1,2,3]
Output:
[
  [3],
Â  [1],
Â  [2],
Â  [1,2,3],
Â  [1,3],
Â  [2,3],
Â  [1,2],
Â  []
]
```

#### Analysis

åˆ—å‡ºä¸€ä¸ªé›†åˆçš„æ‰€æœ‰å­é›†ã€‚

ä¸‰ç§è§£æ³•ã€‚

##### éé€’å½’è§£

æœ€ç›´è§‚çš„æ˜¯ä¸€ä¸ªéé€’å½’è§£ï¼Œè‡ªåº•å‘ä¸Šæ„å»ºæ‰€æœ‰å­é›†ã€‚

1. `[[]]` åˆå§‹åªæœ‰ä¸€ä¸ªç©ºé›†
2. `[[], [1]]` ï¼Œ æœ‰ 1ä¸ªå…ƒç´ ï¼Œ åŠ è¿›å»ï¼Œå’Œä¸åŠ è¿›å»ï¼Œæ„æˆ 2ä¸ª å­é›†ã€‚
3. `[[2], [1, 2]]`ï¼Œ å°†ç¬¬äºŒä¸ªå…ƒç´ åŠ è¿›å»ï¼Œæ„æˆ 2ä¸ªå­é›†ï¼Œä¸ä¸åŠ å…¥ç¬¬äºŒä¸ªå…ƒç´ ï¼Œæ€»å…±æœ‰ 4ä¸ªå­é›†ã€‚
4. ä»¥æ­¤ç±»æ¨ï¼Œ 3ä¸ªå…ƒç´  = 4 + 4 = 8 ä¸ªå­é›†
5. 4 ä¸ªå…ƒç´  = 8 + 8 = 16 ä¸ªå­é›†
6. $n$ ä¸ªå…ƒç´ æœ‰ $2^n$ ä¸ªå­é›†ã€‚

```python
def subsets(self, nums):
    ans = [[]]
    for n in nums:
        ans.extend([subset + [n] for subset in ans])
    return ans
```

##### é€’å½’è§£

æ ¹æ®éé€’å½’è§£å†™é€’å½’è§£ï¼š

```python
def subsets(self, nums):

    def subset(i):
        if i == len(nums):
            return [[]]
        ss = subset(i + 1)
        ss.extend([s + [nums[i]] for s in ss])
        return ss

    return subset(0)
```

##### é€’å½’è§£ 2

è¿™ä¸ªåè€Œä¸å¥½ç†è§£ï¼Œéœ€è¦ç»•å¼¯ã€‚

```python
def subsets(self, nums):
    ans = []

    def dfs(init, path):
        # print(path)
        ans.append(path)
        for i in range(init, len(nums)):
            dfs(i + 1, path + [nums[i]])
    dfs(0, [])
    return ans
```

ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚ æœ€å·¦è¾¹çš„ä¸€ä¸ªåˆ†æ”¯ï¼ŒåŒ…å«æ‰€æœ‰å…ƒç´ ï¼Œæ²¿ç€è·¯å¾„ï¼Œä¾æ¬¡åŒ…æ‹¬  `[], [1], [1, 2], ..., [1, ..., n]` è¿™äº›å­é›†ã€‚

åœ¨ç¬¬1å±‚ï¼Œ åŒ…æ‹¬ `[1], [2], ..., [n]` è¿™äº›å­é›†ã€‚

æ¯ä¸ªè·¯å¾„éƒ½æ˜¯ä¸€ä¸ªå­é›†ã€‚è·¯å¾„ä¸Šçš„èŠ‚ç‚¹å°±æ˜¯å­é›†ä¸­çš„å…ƒç´ ã€‚




#### [Code](../python/78.%20Subsets.py)
