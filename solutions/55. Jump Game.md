### 55. Jump Game

**Array**, **Greedy**    [ğŸ§¡](https://leetcode.com/problems/jump-game)    	[ğŸ’¡](https://leetcode.com/articles/jump-game)

#### Description

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

**Example 1:**

```
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
Â             jump length is 0, which makes it impossible to reach the last index.
```

#### Analysis

è¿™é¢˜ä¸ 45é¢˜ä¸€æ ·ã€‚è¦æ±‚ä¸ä¸€æ ·ï¼Œè¿™ä¸€é¢˜é—®æ˜¯å¦å¯ä»¥åˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®ã€‚

ç”±äºå…ˆåšçš„45é¢˜ï¼Œè°ƒæ•´ä¸€ä¸‹ç»“æœå³å¯ã€‚è¿™é‡Œä¸éœ€è¦è®¡ç®— è·³æ•°ï¼Œæ‰€ä»¥å¯ä»¥çœå»å¾ˆå¤šä»£ç ã€‚

```python
def canJump(self, nums):
    """
    :type nums: List[int]
    :rtype: bool
    """
    max_reach = 0
    for i in range(len(nums)):
        if max_reach < i:
            return False
        max_reach = max(max_reach, i + nums[i])
    return True
```

éå†æ‰€æœ‰ä½ç½®ï¼Œå½“å‘ç° max_reach æ¯”å½“å‰ä½ç½®å°çš„æ—¶å€™ï¼Œå°±è®¤ä¸ºè·³ä¸åˆ°æœ€åä¸€ä¸ªä½ç½®äº†ã€‚

#### Solutions

å‚è€ƒ <https://leetcode.com/problems/jump-game/solution/>

This is a dynamic programming question. Usually, solving and fully understanding a dynamic programming problem is a 4 step process:

1. Start with the recursive backtracking solution
2. Optimize by using a memoization table (top-down dynamic programming)
3. Remove the need for recursion (bottom-up dynamic programming)
4. Apply final tricks to reduce the time / memory complexity

ä¸æˆ‘ä¹‹å‰çš„åšDPé—®é¢˜çš„æ€è·¯ä¸ä¸€æ ·ã€‚å­¦ä¹ äº†ã€‚

è¿™é‡Œç¬¬ä¸€æ­¥å…ˆç”¨ backtracking ç¬¨æ–¹æ³•ï¼Œéå†æ‰€æœ‰çš„è§£ã€‚ç„¶åå†çœ‹çœ‹æ˜¯å¦èƒ½å°†è§£æ”¾åˆ°ä¸€ä¸ªè¡¨ä¸­ï¼ˆæ•°ç»„æˆ–æ˜¯çŸ©é˜µï¼‰ã€‚ ç„¶åä½¿ç”¨ bottom-upçš„æ–¹æ³•ï¼Œå¡«æ»¡æ•´ä¸ªè¡¨ã€‚ æœ€ååšä¸€äº›æ—¶é—´ã€å†…å­˜ä¸Šçš„ä¼˜åŒ–ã€‚

æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œä»»ä½• DPé—®é¢˜å…¶å®éƒ½å¥½ç†è§£å’Œè§£å†³ã€‚

##### 1. backtrackingæ–¹æ³•

è¿™é¢˜çš„backtrackingæ–¹æ³•æ€è·¯å°±æ˜¯æŠŠæ‰€æœ‰å¯èƒ½è§£éå†ä¸€éï¼Œç”¨é€’å½’çš„æ–¹å¼ã€‚ç®—æ³•æ—¶é—´å¤æ‚åº¦ $O(2^N)$

```python
def canJump(self, nums):
    def can_jump(position):
        if position >= len(nums) - 1:
            return True

        furthest_jump = min(position + nums[position], len(nums) - 1)
        for j in range(position + 1, furthest_jump + 1):
            if can_jump(j):
                return True
        return False
    return can_jump(0)
```

##### 2. top-down

ä¸Šé¢çš„æ–¹æ³•æœ‰ç›¸å½“å¤šçš„è®¡ç®—å†—ä½™ï¼šæ¯æ¬¡è·³åˆ°ä¸€ä¸ªä½ç½®ï¼Œéƒ½è¦é‡æ–°è€ƒè™‘åé¢æ‰€æœ‰å¯èƒ½çš„jumpæ–¹å¼ï¼Œå®é™…ä¸Šåªéœ€è¦è€ƒè™‘èƒ½å¦è·³åˆ°æœ€åä¸€ä¸ªä½ç½®å³å¯ã€‚æŠŠæ¯ä¸ªä½ç½®æ˜¯å¦èƒ½åˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®éƒ½è®°å½•åˆ°å†…å­˜ä¸­ï¼Œå°±å¯ä»¥é¿å…è¿™äº›è®¡ç®—å†—ä½™ã€‚

```python
def canJump(self, nums):
    memo = [0] * len(nums)
    memo[-1] = 1   # -1, can't jump,  1, can jump

    def can_jump(position):
        if memo[position] == 1:
            return True
        elif memo[position] == -1:
            return False

        furthest_jump = min(position + nums[position], len(nums) - 1)
        for j in range(position + 1, furthest_jump + 1):
            if can_jump(j):
                memo[j] = 1
                return True
        memo[position] = -1
        return False
    return can_jump(0)
```

##### 3. bottom-up

ä¹Ÿå¯ä»¥ä»å³å‘å·¦é€ä¸ªæ„å»º memoã€‚ å¯¹æ¯ä¸ªä½ç½®ï¼Œå¦‚æœ `position ~ position + nums[position]` èŒƒå›´å†…æœ‰å¯ä»¥åˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®çš„ï¼Œåˆ™ä» `position` ä¹Ÿå¯ä»¥è·³åˆ°æœ€åä¸€ä¸ªä½ç½®

```python
def canJump(self, nums):
    memo = [False] * len(nums)
    memo[-1] = True

    for i in range(len(nums) - 2, -1, -1):
        for j in range(i + 1, min(i + nums[i], len(nums) - 1) + 1):
            if memo[j]:
                memo[i] = True
                break

    return memo[0]
```

##### 4. Greedy

å…¶å®è¿˜å¯ä»¥ç®€åŒ–ã€‚ç®€åŒ–åˆ°æœ€åå°±æˆäº†è´ªå©ªç®—æ³•ã€‚

æ³¨æ„å‰é¢çš„ç®—æ³•åœ¨å¾ªç¯å†…è¿˜è¦éå†ä¸€æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $O(N^2)$ã€‚

å…¶å®åªéœ€è¦ä¸€ä¸ªå˜é‡ï¼š `need_reach` è¡¨ç¤ºéœ€è¦åˆ°è¾¾çš„ä½ç½®å³å¯ã€‚

å¦‚æœ `need_reach`ï¼Œ åœ¨ `position ~ position + nums[position]` èŒƒå›´å†…ï¼Œ åˆ™ `position` å¯ä»¥åˆ°è¾¾æœ€åä½ç½®ï¼Œ å¹¶ä¸”æ‰€æœ‰å¯ä»¥åˆ°è¾¾ `need_reach` çš„éƒ½å¯ä»¥åˆ°è¾¾æœ€åä½ç½®ï¼Œ`position` æˆä¸ºæ–°çš„ `need_reach` ã€‚

æœ€åçœ‹ `need_reach` æ˜¯å¦ä¸º0ï¼Œ å³æ˜¯å¦åªéœ€è¦åˆ°è¾¾å¼€å§‹ä½ç½®ï¼Œå°±å¯ä»¥åˆ°è¾¾æœ€åä½ç½®ã€‚


```python
def canJump(self, nums):
    need_reach = len(nums) - 1
    for i in range(len(nums) - 1, -1, -1):
        if i + nums[i] >= need_reach:
            need_reach = i
    return need_reach == 0
```

ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º $O(N)$ï¼Œ å› ä¸ºå°‘äº†å¾ˆå¤šè®¡ç®—ï¼Œæ‰€ä»¥å¸¸æ•°ä¹Ÿå¾ˆå°ã€‚ æ¯”æœ€å¼€å§‹çš„æ–¹æ³•è¿˜è¦å¥½ã€‚

#### [Code](../python/55.%20Jump%20Game.py)
